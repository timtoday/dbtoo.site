---
title:c时间函数
layout: post
tags:
- Linux
- C/C++
---
<div> <p> C语言的标准库函数包括一系列日期和时间处理函数，它们都在头文件中说明。下面列出了这些函数。在头文件中定义了三种类型：time_t，struct tm和clock_t。</p><p>在头文件中说明的C语言时间函数</p><p>time_t time(time_t *timer);</p><p>double difftime(time_t time1,time_t time2);</p><p>struct tm *gmtime(const time_t *timer);</p><p>struct tm *localtime(const time_t *timer);</p><p>char *asctime(const struct tm *timeptr);</p><p>char *ctime(const time_t *timer);</p><p>size_t strftime(char *s,size_t maxsize,const char *format,const struct tm *timeptr);</p><p>time_t mktime(struct tm *timeptr);</p><p>clock_t clock(void);</p><p> </p><p>下面是我从网上收集到的时间函数集</p><p>asctime（将时间和日期以字符串格式表示）</p><p>相关函数</p><p>time，ctime，gmtime，localtime</p><p>表头文件</p><p>＃i nclude  &lt;time.h&gt;</p><p>定义函数</p><p>char * asctime(const struct tm * timeptr);</p><p>函数说明</p><p>asctime()将参数timeptr所指的tm结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。此函数已经由时区转换成当地时间，字符串格式为:"Wed Jun 30 21:49:08 1993\n"</p><p>返回值</p><p>若再调用相关的时间日期函数，此字符串可能会被破坏。此函数与ctime不同处在于传入的参数是不同的结构。</p><p>附加说明</p><p>返回一字符串表示目前当地的时间日期。</p><p>范例</p><p>＃include  &lt;time.h&gt;</p><p>main()</p><p>{ </p><p>    time_t timep; </p><p>    time (&amp;timep); </p><p>    printf("%s",asctime(gmtime(&amp;timep)));</p><p>}</p><p>执行</p><p>Sat Oct 28 02:10:06 2000</p><p>　</p><p>ctime（将时间和日期以字符串格式表示）</p><p>相关函数</p><p>time，asctime，gmtime，localtime</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>char *ctime(const time_t *timep);</p><p>函数说明</p><p>ctime ()将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果以字符串形态返回。此函数已经由时区转换成当地 时间，字符串格式为"Wed Jun 30 21 :49 :08 1993\n"。若再调用相关的时间日期函数，此字符串可能会被破坏。</p><p>返回值</p><p>返回一字符串表示目前当地的时间日期。</p><p>范例</p><p>＃include  &lt;time.h&gt;</p><p>main()</p><p>{ </p><p>    time_t timep; </p><p>    time (&amp;timep); </p><p>    printf("%s",ctime(&amp;timep));</p><p>}</p><p>执行</p><p>Sat Oct 28 10 : 12 : 05 2000</p><p>　</p><p>gettimeofday（取得目前的时间）</p><p>相关函数</p><p>time，ctime，ftime，settimeofday</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>int gettimeofday ( struct timeval * tv , struct timezone * tz )</p><p>函数说明</p><p>gettimeofday()会把目前的时间有tv所指的结构返回，当地时区的信息则放到tz所指的结构中。</p><p>timeval结构定义为:</p><p>struct timeval{ </p><p>    long tv_sec; /*秒*/ </p><p>    long tv_usec; /*微秒*/</p><p>};</p><p>timezone 结构定义为: </p><p>struct timezone{ </p><p>    int tz_minuteswest; /*和Greenwich 时间差了多少分钟*/ </p><p>    int tz_dsttime; /*日光节约时间的状态*/</p><p>};</p><p>上述两个结构都定义在/usr/include/sys/time.h。tz_dsttime 所代表的状态如下</p><p>DST_NONE /*不使用*/</p><p>DST_USA /*美国*/</p><p>DST_AUST /*澳洲*/</p><p>DST_WET /*西欧*/</p><p>DST_MET /*中欧*/</p><p>DST_EET /*东欧*/</p><p>DST_CAN /*加拿大*/</p><p>DST_GB /*大不列颠*/</p><p>DST_RUM /*罗马尼亚*/</p><p>DST_TUR /*土耳其*/</p><p>DST_AUSTALT /*澳洲（1986年以后）*/</p><p>返回值</p><p>成功则返回0，失败返回－1，错误代码存于errno。附加说明EFAULT指针tv和tz所指的内存空间超出存取权限。</p><p>范例</p><p>＃i nclude  &lt;time.h&gt;</p><p>main(){ </p><p>    struct timeval tv; </p><p>    struct timezone tz; </p><p>    gettimeofday (&amp;tv , &amp;tz);     </p><p>    printf("tv_sec; %d\n", tv,.tv_sec) ; </p><p>    printf("tv_usec; %d\n",tv.tv_usec); </p><p>    printf("tz_minuteswest; %d\n", tz.tz_minuteswest); </p><p>    printf("tz_dsttime, %d\n",tz.tz_dsttime);</p><p>}</p><p>执行</p><p>tv_sec: 974857339</p><p>tv_usec:136996</p><p>tz_minuteswest:-540</p><p>tz_dsttime:0</p><p>　</p><p>gmtime（取得目前时间和日期）</p><p>相关函数</p><p>time,asctime,ctime,localtime</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>struct tm*gmtime(const time_t*timep);</p><p>函数说明</p><p>gmtime()将参数timep 所指的time_t 结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回。</p><p>结构tm的定义为</p><p>struct tm</p><p>{ </p><p>    int tm_sec; </p><p>    int tm_min; </p><p>    int tm_hour; </p><p>    int tm_mday; </p><p>    int tm_mon; </p><p>    int tm_year; </p><p>    int tm_wday; </p><p>    int tm_yday; </p><p>    int tm_isdst;</p><p>};</p><p>int tm_sec 代表目前秒数，正常范围为0-59，但允许至61秒</p><p>int tm_min 代表目前分数，范围0-59</p><p>int tm_hour 从午夜算起的时数，范围为0-23</p><p>int tm_mday 目前月份的日数，范围01-31</p><p>int tm_mon 代表目前月份，从一月算起，范围从0-11</p><p>int tm_year 从1900 年算起至今的年数</p><p>int tm_wday 一星期的日数，从星期一算起，范围为0-6</p><p>int tm_yday 从今年1月1日算起至今的天数，范围为0-365</p><p>int tm_isdst 日光节约时间的旗标</p><p>此函数返回的时间日期未经时区转换，而是UTC时间。</p><p>返回值</p><p>返回结构tm代表目前UTC 时间</p><p>范例</p><p>＃include  &lt;time.h&gt;</p><p>main(){ </p><p>    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; </p><p>    time_t timep; </p><p>    struct tm *p; </p><p>    time(&amp;timep); </p><p>    p=gmtime(&amp;timep); </p><p>    printf("%d%d%d",(1900+p-&gt;tm_year), (1+p-&gt;tm_mon),p-&gt;tm_mday); </p><p>    printf("%s%d;%d;%d\n", wday[p-&gt;tm_wday], p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);</p><p>}</p><p>执行</p><p>2000/10/28 Sat 8:15:38</p><p>　</p><p>localtime（取得当地目前时间和日期）</p><p>相关函数</p><p>time, asctime, ctime, gmtime</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>struct tm *localtime(const time_t * timep);</p><p>函数说明</p><p>localtime()将参数timep所指的time_t结构中的信息转换成真实世界所使用的时间日期表示方法，然后将结果由结构tm返回。结构tm的定义请参考gmtime()。此函数返回的时间日期已经转换成当地时区。</p><p>返回值</p><p>返回结构tm代表目前的当地时间。</p><p>范例</p><p>＃include  &lt;time.h&gt;</p><p>main(){ </p><p>    char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"}; </p><p>    time_t timep; </p><p>    struct tm *p; </p><p>    time(&amp;timep); </p><p>    p=localtime(&amp;timep); /*取得当地时间*/ </p><p>    printf ("%d%d%d ", (1900+p-&gt;tm_year),( l+p-&gt;tm_mon), p-&gt;tm_mday); </p><p>    printf("%s%d:%d:%d\n", wday[p-&gt;tm_wday],p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);</p><p>}</p><p>执行</p><p>2000/10/28 Sat 11:12:22</p><p>　</p><p>mktime（将时间结构数据转换成经过的秒数）</p><p>相关函数</p><p>time，asctime，gmtime，localtime</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>time_t mktime(strcut tm * timeptr);</p><p>函数说明</p><p>mktime()用来将参数timeptr所指的tm结构数据转换成从公元1970年1月1日0时0分0 秒算起至今的UTC时间所经过的秒数。</p><p>返回值</p><p>返回经过的秒数。</p><p>范例</p><p>/* 用time()取得时间（秒数），利用localtime()</p><p>转换成struct tm 再利用mktine（）将struct tm转换成原来的秒数*/</p><p>＃include  &lt;time.h&gt;</p><p>main()</p><p>{ </p><p>    time_t timep; </p><p>    strcut tm *p; </p><p>    time(&amp;timep); </p><p>    printf("time() : %d \n",timep); </p><p>    p=localtime(&amp;timep); </p><p>    timep = mktime(p); </p><p>    printf("time()-&gt;localtime()-&gt;mktime():%d\n",timep);</p><p>}</p><p>执行</p><p>time():974943297</p><p>time()-&gt;localtime()-&gt;mktime():974943297</p><p>　</p><p>settimeofday（设置目前时间）</p><p>相关函数</p><p>time，ctime，ftime，gettimeofday</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>int settimeofday ( const struct timeval *tv,const struct timezone *tz);</p><p>函数说明</p><p>settimeofday()会把目前时间设成由tv所指的结构信息，当地时区信息则设成tz所指的结构。详细的说明请参考gettimeofday()。注意，只有root权限才能使用此函数修改时间。</p><p>返回值</p><p>成功则返回0，失败返回－1，错误代码存于errno。</p><p>错误代码</p><p>EPERM 并非由root权限调用settimeofday（），权限不够。</p><p>EINVAL 时区或某个数据是不正确的，无法正确设置时间。</p><p>　</p><p>time（取得目前的时间）</p><p>相关函数</p><p>ctime，ftime，gettimeofday</p><p>表头文件</p><p>＃include  &lt;time.h&gt;</p><p>定义函数</p><p>time_t time(time_t *t);</p><p>函数说明</p><p>此函数会返回从公元1970年1月1日的UTC时间从0时0分0秒算起到现在所经过的秒数。如果t 并非空指针的话，此函数也会将返回值存到t指针所指的内存。</p><p>返回值</p><p>成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno中。</p><p>范例</p><p>＃include  &lt;time.h&gt;</p><p>mian()</p><p>{ </p><p>    int seconds= time((time_t*)NULL); </p><p>    printf("%d\n",seconds);</p><p>}</p><p>执行</p><p>9.73E+08</p><p>------------------------------------------------------------------------------------------------</p><p>关键字：c语言 时间函数 time.h c语言时间函数，时间头函数</p><p> </p><p>所有代码编译环境：MSVC6.0</p><p> </p><p>1，时间的获取：</p><p>通过time()函数来获得日历时间（Calendar Time），其原型为：time_t time(time_t * timer);</p><p> </p><p>#include "stdafx.h"</p><p>#include "time.h"</p><p>#include "stdio.h"</p><p>#include "stdlib.h"</p><p> </p><p>int main(void)</p><p>{</p><p>struct tm t;            //定义tm时间结构，用来存储时间格式的数据信息</p><p>time_t t_of_day;     //定义time_t时间结构</p><p>t.tm_year=2006-1900;//以1900年为标准计算时间</p><p>t.tm_mon=6;                 //为结构体成员赋值</p><p>t.tm_mday=1;</p><p>t.tm_hour=0;</p><p>t.tm_min=0;</p><p>t.tm_sec=1;</p><p>t.tm_isdst=0;</p><p>t_of_day=mktime(&amp;t);</p><p>//使用mktime（）函数将用tm结构表示的时间转化为日历时间：time_t型变量。 其函数原型如下：time_t mktime(struct tm * timeptr);ctime()函数(参数为time_t结构)将时间以固定的格式显示出来，返回值是char*型的字符串。</p><p>return 0;</p><p>}</p><p> </p><p>2，时间的储存，通过预定义的两种结构来存储：</p><p>1，日历时间（Calendar Time）是通过time_t数据类型来表示的，用time_t表示的时间（日历时间）是从一个时间点（例如：1970年1月1日0时0分0秒）到此时的秒数。在time.h中，我们也可以看到time_t是一个长整型数：</p><p> </p><p>#ifndef _TIME_T_DEFINED</p><p>typedef long time_t;         /* 时间值 */</p><p>#define _TIME_T_DEFINED      /* 避免重复定义 time_t */</p><p>#endif</p><p>2，在标准C/C++中，我们可通过tm结构来获得日期和时间，tm结构在time.h中的定义如下：</p><p> </p><p>struct tm {</p><p>        int tm_sec;     /* 秒 – 取值区间为[0,59] */</p><p>        int tm_min;     /* 分 - 取值区间为[0,59] */</p><p>        int tm_hour;    /* 时 - 取值区间为[0,23] */</p><p>        int tm_mday;    /* 一个月中的日期 - 取值区间为[1,31] */</p><p>        int tm_mon;     /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</p><p>        int tm_year;    /* 年份，其值等于实际年份减去1900 */</p><p>        int tm_wday;    /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</p><p>        int tm_yday;    /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</p><p>        int tm_isdst;   /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/</p><p>        };</p><p> </p><p>3，时间的显示：</p><p>time.h头文件中提供了asctime()函数(参数为tm结构指针)和ctime() 函数(参数为time_t结构)将时间以固定的格式显示出来，两者的返回值都是char*型的字符串。返回的时间格式为：星期几 月份 日期 时:分:秒 年\n\0；time.h还提供了两种不同的函数将日历时间（一个用time_t表示的整数）转换为我们平时看到的把年月日时分秒分开显示的时间格式 tm：</p><p>struct tm * gmtime(const time_t *timer);</p><p>gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），并返回一个tm结构体来保存这个时间</p><p>struct tm * localtime(const time_t * timer);localtime()函数是将日历时间转化为本地时间</p><p>#include &lt;stdafx.h&gt;</p><p>#include &lt;time.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p> </p><p>int main(void)</p><p>{</p><p>       struct tm *local,*ptr; //定义tm结构指针存储时间信息</p><p>       time_t t;                       //时间结构或者对象</p><p>       t=time(NULL);                     //获取当前系统的日历时间</p><p>       //通过time()函数来获得日历时间（Calendar Time），</p><p>       //其原型为：time_t time(time_t * timer);</p><p>       local=localtime(&amp;t);//localtime()函数是将日历时间转化为本地时间</p><p>       printf("Local hour is: %d\n",local-&gt;tm_hour);//输出tm结构体的时间成员</p><p>       printf("UTC hour is: %d\n",local-&gt;tm_hour);</p><p>       //local=gmtime(&amp;t);</p><p>       //gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），</p><p>       //并返回一个tm结构体来保存这个时间  </p><p>       ptr=gmtime(&amp;t);//将日历时间转化为世界标准时间</p><p>       printf("The UTC time is %s\n",asctime(ptr)); //格式化输出世界标准时间</p><p>       printf("The local time is %s\n",ctime(&amp;t));//输出本地时间</p><p>       /*asctime()函数(参数为tm结构指针)和ctime()函数(参数为time_t结构)将时间以固定的格式显示出来，两者的返回值都是char*型的字符串。返回的时间格式为：星期几 月份 日期 时:分:秒 年\n\0 */</p><p>       return 0;</p><p>}</p><p> </p><p>4，时间差的计算：</p><p>所用函数：C/C++中的计时函数是clock()，而与其相关的数据类型是clock_t。在MSDN中对clock函数定义如下：</p><p>clock_t clock( void );函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，clock_t是一个长整形数，保存时间的数据类型。在time.h文件中，还定义了一个常量CLOCKS_PER_SEC，它用来表示一 秒钟会有多少个时钟计时单元，其定义如下：</p><p>#define CLOCKS_PER_SEC ((clock_t)1000)</p><p>每过千分之一秒（1毫秒），调用clock（）函数返回的值就加1，时钟计时单元的长度为1 毫秒，那么计时的精度也为1毫秒，那么我们可不可以通过改变CLOCKS_PER_SEC的定义，通过把它定义的大一些，从而使计时精度更高呢？这样是不 行的。在标准C/C++中，最小的计时单位是一毫秒。double difftime(time_t time1, time_t time0);这个函数来计算时间差。</p><p> </p><p>#include "stdafx.h"</p><p>#include "time.h"</p><p>#include "stdio.h"</p><p>#include "stdlib.h"</p><p>int main(void)</p><p>{</p><p>    time_t c_start,t_start, c_end,t_end;  </p><p>    c_start = clock();</p><p>       t_start = time(NULL) ;</p><p>    system("pause") ;</p><p>       c_end = clock();</p><p>    t_end = time(NULL) ;</p><p>    printf("The pause used %f ms by time().\n",difftime(c_end,c_start)) ; </p><p>       printf("The pause used %f s by clock().\n",difftime(t_end,t_start)) ;</p><p>    system("pause");</p><p>    return 0;</p><p>}</p><p>5，时间的其他用途</p><p>用作随机数的种子，由于时间获得的实际上是一个double类型的长整数，通过time(NULL)函数获得，作为srand(time(NULL))的种子产生随机数比较好。</p><p> </p><p>#include "stdafx.h"</p><p>#include "time.h"</p><p>#include "stdio.h"</p><p>#include "stdlib.h"</p><p>int main(void)</p><p>{</p><p>       srand(time(NULL));</p><p>       //设置种子,如果将这个函数注释掉，每次运行程序得到的随机数十相同的</p><p>       for(int i=0;i&lt;100;i++)</p><p>       {</p><p>              printf("%d\t",rand());</p><p>       }</p><p>    system("pause");</p><p>    return 0;</p><p>}</p> </div>