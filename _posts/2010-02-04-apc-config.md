---
title:apc的配置与测试
layout: post
tags:
- Linux
- Php
---
<div> The Alternative PHP Cache (APC) is a free and open opcode cache for PHP.    It was conceived of to provide a free, open, and robust framework for    caching and optimizing PHP intermediate code.<br/>APC除了能作CACHE外，更大的优点在于它还能优化php代码，据说优化效果已经超过了ZendOptmizer呢。在这里可以下载APC的最新扩展包： <a href="http://pecl.php.net/package/APC" target="_blank">http://pecl.php.net/package/APC</a><br/><br/>至于php扩展怎么安装我就不写了，贴一下我的php.ini 吧<br/>[APC]<br/><br/>apc.cache_by_default = on<br/>;sys<br/>; 是否默认对所有文件启用缓冲。<br/>; 若设为off并与以加号开头的apc.filters指令一起用，则文件仅在匹配过滤器时才被缓存。<br/><br/>apc.enable_cli = off<br/>;sys<br/>; 是否为cli版本启用apc功能，仅用于测试和调试目的才打开此指令。<br/><br/>apc.enabled = on<br/>; 是否启用apc，如果apc被静态编译进php又想禁用它，这是唯一的办法。<br/><br/>apc.file_update_protection = 2<br/>;sys<br/>; 当你在一个运行中的服务器上修改文件时，你应当执行原子操作。<br/>; 也就是先写进一个临时文件，然后将该文件重命名(mv)到最终的名字。<br/>; 文本编辑器以及 cp, tar 等程序却并不是这样操作的，从而导致有可能缓冲了残缺的文件。<br/>; 默认值 2 表示在访问文件时如果发现修改时间距离访问时间小于 2 秒则不做缓冲。<br/>; 那个不幸的访问者可能得到残缺的内容，但是这种坏影响却不会通过缓存扩大化。<br/>; 如果你能确保所有的更新操作都是原子操作，那么可以用 0 关闭此特性。<br/>; 如果你的系统由于大量的io操作导致更新缓慢，你就需要增大此值。<br/><br/>;apc.filters =<br/>;sys<br/>; 一个以逗号分隔的posix扩展正则表达式列表。<br/>; 如果源文件名与任意一个模式匹配，则该文件不被缓存。<br/>; 注意，用来匹配的文件名是传递给include/require的文件名，而不是绝对路径。<br/>; 如果正则表达式的第一个字符是"+"则意味着任何匹配表达式的文件会被缓存，<br/>; 如果第一个字符是"-"则任何匹配项都不会被缓存。"-"是默认值，可以省略掉。<br/><br/>apc.ttl = 0<br/>;sys<br/>; 缓存条目在缓冲区中允许逗留的秒数。0 表示永不超时。建议值为7200~36000。<br/>; 设为 0 意味着缓冲区有可能被旧的缓存条目填满，从而导致无法缓存新条目。<br/><br/>apc.user_ttl = 0<br/>;sys<br/>; 类似于apc.ttl，只是针对每个用户而言，建议值为7200~36000。<br/>; 设为 0 意味着缓冲区有可能被旧的缓存条目填满，从而导致无法缓存新条目。<br/><br/>apc.gc_ttl = 3600<br/>;sys<br/>; 缓存条目在垃圾回收表中能够存在的秒数。<br/>; 此值提供了一个安全措施，即使一个服务器进程在执行缓存的源文件时崩溃，<br/>; 而且该源文件已经被修改，为旧版本分配的内存也不会被回收，直到达到此ttl值为止。<br/>; 设为零将禁用此特性。<br/><br/>apc.include_once_override = off<br/>;sys<br/>; 关于该指令目前尚无说明文档，参见：http://pecl.php.net/bugs/bug.php?id=8754<br/>; 请保持为off，否则可能导致意想不到的结果。<br/><br/>apc.max_file_size = 1m<br/>;sys<br/>; 禁止大于此尺寸的文件被缓存。<br/><br/>apc.mmap_file_mask =<br/>;sys<br/>; 如果使用–enable-mmap(默认启用)为apc编译了mmap支持，<br/>; 这里的值就是传递给mmap模块的mktemp风格的文件掩码(建议值为"/tmp/apc.xxxxxx")。<br/>; 该掩码用于决定内存映射区域是否要被file-backed或者shared memory backed。<br/>; 对于直接的file-backed内存映射，要设置成"/tmp/apc.xxxxxx"的样子(恰好6个x)。<br/>; 要使用posix风格的shm_open/mmap就需要设置成"/apc.shm.xxxxxx"的样子。<br/>; 你还可以设为"/dev/zero"来为匿名映射的内存使用内核的"/dev/zero"接口。<br/>; 不定义此指令则表示强制使用匿名映射。<br/><br/>apc.num_files_hint = 1000<br/>;sys<br/>; web服务器上可能被包含或被请求的不同源文件的大致数量(建议值为1024~4096)。<br/>; 如果你不能确定，则设为 0 ；此设定主要用于拥有数千个源文件的站点。<br/><br/>apc.optimization = 0<br/>; 优化级别(建议值为 0 ) 。<br/>; 正整数值表示启用优化器，值越高则使用越激进的优化。<br/>; 更高的值可能有非常有限的速度提升，但目前尚在试验中。<br/><br/>apc.report_autofilter = off<br/>;sys<br/>; 是否记录所有由于early/late binding原因而自动未被缓存的脚本。<br/><br/>apc.shm_segments = 1<br/>;sys<br/>; 为编译器缓冲区分配的共享内存块数量(建议值为1)。<br/>; 如果apc耗尽了共享内存，并且已将apc.shm_size指令设为系统允许的最大值，<br/>; 你可以尝试增大此值。<br/><br/>apc.shm_size = 30<br/>;sys<br/>; 每个共享内存块的大小(以mb为单位，建议值为128~256)。<br/>; 有些系统(包括大多数bsd变种)默认的共享内存块大小非常少。<br/><br/>apc.slam_defense = 0<br/>;sys(反对使用该指令，建议该用apc.write_lock指令)<br/>; 在非常繁忙的服务器上，无论是启动服务还是修改文件，<br/>; 都可能由于多个进程企图同时缓存一个文件而导致竞争条件。<br/>; 这个指令用于设置进程在处理未被缓存的文件时跳过缓存步骤的百分率。<br/>; 比如设为75表示在遇到未被缓存的文件时有75%的概率不进行缓存，从而减少碰撞几率。<br/>; 鼓励设为 0 来禁用这个特性。<br/><br/>apc.stat = on<br/>;sys<br/>; 是否启用脚本更新检查。<br/>; 改变这个指令值要非常小心。<br/>; 默认值 on 表示apc在每次请求脚本时都检查脚本是否被更新，<br/>; 如果被更新则自动重新编译和缓存编译后的内容。但这样做对性能有不利影响。<br/>; 如果设为 off 则表示不进行检查，从而使性能得到大幅提高。<br/>; 但是为了使更新的内容生效，你必须重启web服务器。<br/>; 这个指令对于include/require的文件同样有效。但是需要注意的是，<br/>; 如果你使用的是相对路径，apc就必须在每一次include/require时都进行检查以定位文件。<br/>; 而使用绝对路径则可以跳过检查，所以鼓励你使用绝对路径进行include/require操作。<br/><br/>apc.user_entries_hint = 100<br/>;sys<br/>; 类似于num_files_hint指令，只是针对每个不同用户而言。<br/>; 如果你不能确定，则设为 0 。<br/><br/>apc.write_lock = on<br/>;sys<br/>; 是否启用写入锁。<br/>; 在非常繁忙的服务器上，无论是启动服务还是修改文件，<br/>; 都可能由于多个进程企图同时缓存一个文件而导致竞争条件。<br/>; 启用该指令可以避免竞争条件的出现。<br/><br/>apc.rfc1867 = off<br/>;sys<br/>; 打开该指令后，对于每个恰好在file字段之前含有apc_upload_progress字段的上传文件，<br/>; apc都将自动创建一个upload_的用户缓存条目(就是apc_upload_progress字段值)。<br/><br/>---------------------------------------------------------------------------------<br/>now test it:...<br/>&lt;?php<br/>$bar = 'BAR';  <br/>apc_store('foo', $bar);     //cache it<br/>var_dump(apc_fetch('foo')); //get out<br/><br/>//貌似有点像memcached<br/> ?&gt;<br/>?&gt; </div>